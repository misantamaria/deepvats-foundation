# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/encoder.ipynb.

# %% auto 0
__all__ = ['ENCODER_EMBS_MODULE_NAME', 'DCAE_torch', 'kwargs_to_gpu_', 'kwargs_to_cpu_', 'get_acts', 'get_acts_moment',
           'sure_eval_moment', 'get_enc_embs_ensure_batch_size_', 'get_enc_embs_MVP',
           'get_enc_embs_MVP_set_stride_set_batch_size', 'get_enc_embs_moment', 'get_enc_embs_moment_reconstruction',
           'watch_gpu', 'get_enc_embs_moirai', 'get_enc_embs', 'get_enc_embs_set_stride_set_batch_size',
           'random_windows', 'windowed_dataset', 'setup_scheduler', 'prepare_train_and_eval_dataloaders',
           'fine_tune_moment_compute_loss_check_sizes_', 'fine_tune_moment_compute_loss',
           'fine_tune_moment_eval_preprocess', 'fine_tune_moment_eval_step_', 'fine_tune_moment_eval_',
           'fine_tune_moment_train_loop_step_', 'fine_tune_moment_train_', 'fine_tune_moment_single_',
           'fine_tune_moment_', 'fine_tune_mvp_step_', 'fine_tune_mvp_train_loop_step_', 'fine_tune_mvp_train_',
           'fine_tune_mvp_single_', 'fine_tune_mvp_', 'fine_tune_']

# %% ../nbs/encoder.ipynb 2
from .memory import *
from .utils import Mssg
from .utils import Time
from .utils import print_flush

# %% ../nbs/encoder.ipynb 5
import pandas as pd
import numpy as np
from fastcore.all import *
from tsai.callback.MVP import *
from tsai.imports import *
from tsai.models.InceptionTimePlus import InceptionTimePlus
from tsai.models.explainability import get_acts_and_grads
from tsai.models.layers import *
from tsai.data.validation import combine_split_data
from fastai.callback.hook import hook_outputs
from momentfm import MOMENTPipeline
from gluonts.dataset.pandas import PandasDataset
import time
import einops
import traceback

# %% ../nbs/encoder.ipynb 8
class DCAE_torch(Module):
    def __init__(self, c_in, seq_len, delta, nfs=[64, 32, 12], kss=[10, 5, 5],
                 pool_szs=[2,2,3], output_fsz=10):
        """
        Create a Deep Convolutional Autoencoder for multivariate time series of `d` dimensions,
        sliced with a window size of `w`. The parameter `delta` sets the number of latent features that will be
        contained in the Dense layer of the network. The the number of features
        maps (filters), the filter size and the pool size can also be adjusted."
        """
        assert all_equal([len(x) for x in [nfs, kss, pool_szs]], np.repeat(len(nfs), 3)), \
            'nfs, kss, and pool_szs must have the same length'
        assert np.prod(pool_szs) == nfs[-1], \
            'The number of filters in the last conv layer must be equal to the product of pool sizes'
        assert seq_len % np.prod(pool_szs) == 0, \
            'The product of pool sizes must be a divisor of the window size'
        layers = []
        for i in range_of(kss):
            layers += [Conv1d(ni=nfs[i-1] if i>0 else c_in, nf=nfs[i], ks=kss[i]),
                       nn.MaxPool1d(kernel_size=pool_szs[i])]
        self.downsample = nn.Sequential(*layers)
        self.bottleneck = nn.Sequential(OrderedDict([
            ('flatten', nn.Flatten()),
            ('latent_in', nn.Linear(seq_len, delta)),
            ('latent_out', nn.Linear(delta, seq_len)),
            ('reshape', Reshape(nfs[-1], seq_len // np.prod(pool_szs)))
        ]))
        layers = []
        for i in reversed(range_of(kss)):
            layers += [Conv1d(ni=nfs[i+1] if i != (len(nfs)-1) else nfs[-1],
                              nf=nfs[i], ks=kss[i]),
                       nn.Upsample(scale_factor=pool_szs[i])]
        layers += [Conv1d(ni=nfs[0], nf=c_in, kernel_size=output_fsz)]
        self.upsample = nn.Sequential(*layers)


    def forward(self, x):
        x = self.downsample(x)
        x = self.bottleneck(x)
        x = self.upsample(x)
        return x

# %% ../nbs/encoder.ipynb 11
ENCODER_EMBS_MODULE_NAME = {
    InceptionTimePlus: 'backbone', # for mvp based models
    DCAE_torch: 'bottleneck.latent_in'#,
    #MoiraiForecast: 'mask_encoding' #TODO: check
    
}

# %% ../nbs/encoder.ipynb 13
def kwargs_to_gpu_(**kwargs):
    for key in kwargs:
        try: #if not able to be moved, just not move it
            kwargs[key] = kwargs[key].to("cuda")
        except:
            continue
    
def kwargs_to_cpu_(**kwargs):
    for key in kwargs:
        try: #if not able to be moved, just not move it
            kwargs[key] = kwargs[key].cpu()
        except:
            continue
   

# %% ../nbs/encoder.ipynb 14
def get_acts(
    model : torch.nn.Module, 
    module: torch.nn.Module, 
    cpu   : bool, 
    verbose : int = 0,
    retry: bool = False,
    acts_indices: List [ int ] = None,
    #- Printing options for debugging
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a',
    continue_if_fail: bool          = False,
    **model_kwargs #Parameters of the model
):
    if verbose > 0:
        print_flush(f"--> get acts | acts indices: {acts_indices}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    if cpu:
        if verbose > 0: print_flush(f"get acts | Moving to cpu", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
        for key in model_kwargs:
            try: #if not able to be moved, just not move it
                model_kwargs[key] = model_kwargs[key].cpu()
            except:
                continue
        model.to("cpu")
    else:
        if verbose > 0: print_flush(f"get acts | Moving to gpu", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
        for key in model_kwargs:
            try: #if not able to be moved, just not move it
                model_kwargs[key] = model_kwargs[key].to("cuda")
            except:
                continue
        model.to("cuda")
    if verbose > 0: print_flush(f"get acts | Add hooks", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    h_act = hook_outputs([module], detach = True, cpu = cpu, grad = False)
    with torch.no_grad():
        if verbose > 0: print_flush(f"get acts | --> Run forward", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
        if retry:
            if verbose > 0: print_flush(f"get acts | Retry", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
            try: 
                preds = model.eval()(**model_kwargs)
            except Exception as e:
                print_flush(f"get acts | Retry | Error: {e}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                print_flush(f"get acts | Retry | Kwargs: {model_kwargs}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                if not cpu:
                    print_flush(f"get acts | Retry | Moving to cpu", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                    for key in model_kwargs:
                        try: #if not able to be moved, just not move it
                            model_kwargs[key] = model_kwargs[key].cpu()
                        except:
                            continue
                    model.to("cpu")
                    if verbose > 0: print_flush(f"get acts | Retry | cpu", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                    print_flush(f"get acts | Retry | Get acts", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                    preds = model.eval()(**model_kwargs)
        else:
            if verbose > 2: print_flush(f"get acts | No Retry | Get acts | model kwargs: {model_kwargs}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
            preds = model.eval()(**model_kwargs)
    if acts_indices is None:
        res = [o.stored for o in h_act]
    else: 
        stored = [o.stored for o in h_act]
        res = [stored[i] for i in acts_indices]
        if len(acts_indices) == 1:
            res = res[0]
        del stored
    if verbose > 0: print_flush(f"get acts | Run forward -->", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    if verbose > 0:print_flush(f"get acts -->", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    return res

# %% ../nbs/encoder.ipynb 15
def get_acts_moment(
    enc_learn, 
    cpu             : bool          = False, 
    verbose         : int           = 0, 
    y               : List [ float ]= [], 
    mask                            = None, 
    padd_step       : int           = 100, 
    # Parameters for avoiding errors
    retry           : bool          = False, 
    max_trials      : int           = 5,
    # Activation selector (various vectors in the acts)
    acts_indices    : List [ int ]  = [0],
    #- Printing options for debugging
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a',
    continue_if_fail: bool          = False
):
    success = False 
    trial = 0
    embs = None
    while not success and trial < max_trials:
        trial += 1
        try:
            if verbose > 0: print_flush(f"get_acts_moment | Trial {trial} | x_enc ~ {y.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
            embs = get_acts(
                model = enc_learn,
                #module = enc_learn.encoder.dropout,
                module = enc_learn.head.dropout,
                cpu = cpu,
                verbose = 0,
                x_enc = y,
                retry = retry,
                acts_indices = acts_indices,
                mask = mask,
                print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, print_time = print_to_path
            )
            success = True
            if verbose > 0 and acts_indices == [0] : print_flush(f"get_acts_moment | Trial {trial} | embs ~ {embs.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
        except Exception as e:
            if trial == max_trials - 1 : raise
            if verbose > 0:
                print_flush(f"get_acts_moment | Trial {trial} | About to pad X (encoder input) | exception {e} | padd step: {padd_step}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                print_flush(f"get_acts_moment | Trial {trial} | y ~ {y.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
            if "tensor a" in str(e) and "tensor b" in str(e):
                match = re.search(r'tensor a \((\d+)\) must match the size of tensor b \((\d+)\)', str(e))
                tensor_a_size = int(match.group(1))
                tensor_b_size = int(match.group(2))
                padd = True
                if trial > 1: 
                    if verbose > 0: print_flush(f"------------------- Trial {trial}  -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                    if tensor_a_size > tensor_a_size_old:
                        if verbose > 0:  print_flush(f"------------------- Trial {trial} | a > a_old -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                        padd = False
                        y = y [ ..., : tensor_a_size - tensor_b_size]
                        if verbose > 0: print_flush(f"------------------- Trial {trial} |a > a_old | Reduced |  y ~ {y.shape} -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                if padd:
                    if verbose > 0: print_flush(f"------------------- Trial {trial} | Padd -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                    if tensor_a_size > tensor_b_size: 
                        if verbose > 0: print_flush(f"------------------- Trial {trial} | Padd | a > b -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                        padd_step = tensor_a_size - tensor_b_size
                    y = torch.nn.functional.pad(y,(0,padd_step))
                tensor_a_size_old = tensor_a_size
            else:
                if verbose > 0: print_flush("Not the usual error. No padding, just fail", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                raise
                
    return embs

# %% ../nbs/encoder.ipynb 16
def sure_eval_moment(
    enc_learn, 
    cpu, 
    verbose, 
    y, 
    input_mask = None, 
    mask = None, 
    padd_step = 100, 
    retry = False, 
    max_trials = 5, 
    acts_indices = [0],
    #- Printing options for debugging
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a',
    continue_if_fail: bool          = False
):
    if verbose > 0: print_flush(f"---> sure_eval_moment", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    device = "cpu" if cpu else torch.cuda.current_device()
    y_copy = y.clone()
    y_copy.to("cpu")
    if verbose > 0: print_flush(f"sure_eval_moment | cpu | {cpu} | device | {device}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path) 
    success = False 
    trial = 0
    output = None
    
    while not success and trial < max_trials:
        trial += 1
        try:
            if verbose > 0: print_flush(f"sure_eval_moment | Trial {trial} | x_enc ~ {y.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
            if input_mask is not None: input_mask = input_mask.to(device)
            if mask is not None: mask = mask.to(device)
            y = y.to(device)
            enc_learn = enc_learn.to(device)
            if verbose > 0: 
                print_flush(f"sure_eval_moment | Trial {trial} | device {device} | input_mask~{input_mask.shape} device: {input_mask.device if input_mask is not None else 'None'}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                print_flush(f"sure_eval_moment | Trial {trial} | device {device} | mask device~{mask.shape}: {mask.device if mask is not None else 'None'}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                print_flush(f"sure_eval_moment | Trial {trial} | device {device} | y~{y.shape} device: {y.device}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
            output = enc_learn(x_enc = y, input_mask = input_mask, mask = mask)
            success = True
            if verbose > 0 and acts_indices == [0] : 
                print_flush(f"sure_eval_moment | Trial {trial} | embs ~ {embs.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        except Exception as e:
            if verbose > 0:
                print_flush(f"sure_eval_moment | Trial {trial} | About to pad X (encoder input) | exception {e} | padd step: {padd_step}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                print_flush(f"sure_eval_moment | Trial {trial} | y ~ {y.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                traceback.print_exc()
            if "tensor a" in str(e) and "tensor b" in str(e) and "dimension" in str(e):
                match = re.search(r'tensor a \((\d+)\) must match the size of tensor b \((\d+)\) at non-singleton dimension (\d+)', str(e))
                tensor_a_size = int(match.group(1))
                tensor_b_size = int(match.group(2))
                dimension = int(match.group(3))
                match dimension:
                    case 2 | 1:
                        padd = True
                        if trial > 1: 
                            if verbose > 0: print_flush(f"------------------- Trial {trial}  -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                            if tensor_a_size > tensor_a_size_old:
                                if verbose > 0: print_flush(f"------------------- Trial {trial} | a > a_old -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                                padd = False
                                y = y [ ..., : tensor_a_size - tensor_b_size]
                                if verbose > 0: print_flush(f"------------------- Trial {trial} |a > a_old | Reduced |  y ~ {y.shape} -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                        if padd:
                            if verbose > 0: print_flush(f"------------------- Trial {trial} | Padd -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                            if tensor_a_size > tensor_b_size: 
                                if verbose > 0: print_flush(f"------------------- Trial {trial} | Padd | a > b -----------------", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                                padd_step = tensor_a_size - tensor_b_size
                            y = torch.nn.functional.pad(y,(0,padd_step))
                        tensor_a_size_old = tensor_a_size
                    #case 1: 
                    #    if verbose > 0:
                    #        print_flush(f"sure_eval_moment | Trial {trial} | Error dimension 0 | mask ~ {mask.shape} | mask_input ~ {input_mask.shape} | batch ~ {y.shape}")
                    #        if mask.shape[1] < y.shape[2]: mask = torch.nn.functional.pad(mask,(0,y.shape[2]-mask.shape[1]))
                    #        if input_mask.shape[2] < y.shape[2]: mask = torch.nn.functional.pad(input_mask,(0,y.shape[2]-input_mask.shape[2]))

                    case 0:
                        if verbose > 0: 
                            print_flush(f"sure_eval_moment | Trial {trial} | Error dimension 0 | mask ~ {mask.shape} | mask_input ~ {input_mask.shape} | batch ~ {y.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)                    
                        if mask.shape[0] > y.shape[0]:
                            mask = mask[:y.shape[0]]
                        if input_mask.shape[0] > y.shape[0]:
                            input_mask = input_mask[:y.shape[0]]
                        
                        if mask.shape[0] < y.shape[0]:
                            extra_rows_shape = (-mask.shape[0]+y.shape[0],mask.shape[1])
                            if verbose > 0: print_flush(f"sure_eval_moment | Trial {trial} | Mask lower than batch | rows to add: {extra_rows_shape }", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                            extra_rows = torch.zeros(extra_rows_shape, dtype = torch.float32)
                            mask = torch.cat((mask, extra_rows), dim=0)
                        if input_mask.shape[0] < y.shape[0]:
                            extra_rows_shape = (-input_mask.shape[0]+y.shape[0],y.shape[1], y.shape[2])
                            if verbose > 0: print_flush(f"sure_eval_moment | Trial {trial} | Mask lower than batch | rows to add: {extra_rows_shape }", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                            extra_rows = torch.zeros(extra_rows_shape, dtype = torch.float32)
                            input_mask = torch.cat((input_mask, extra_rows), dim=0)
            else:
                if verbose > 0: 
                    print_flush("Not the usual error. No padding, just fail", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                if not continue_if_fail: raise
        #if verbose > 0: print_flush(f"sure_eval_moment | output {output.__class__} | enc_learn {enc_learn.__class__} -->", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        if verbose > 0: print_flush(f"sure_eval_moment | output {output.__class__} -->", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    y = y_copy
    if not cpu: y.to("cuda")
    
    return output, enc_learn

# %% ../nbs/encoder.ipynb 18
from fastai.learner import Learner
from tsai.data.core import TSDataLoaders

# %% ../nbs/encoder.ipynb 21
def get_enc_embs_ensure_batch_size_(
    dls        : TSDataLoaders,
    batch_size : int = None,
    verbose    : int = 0
) -> None:
    if batch_size is None:
        if verbose > 1: 
            print_flush(f"[ Get Encoder Embeddings Ensure Batch Size ] No batch size proposed", verbose = verbose)
        if dls.bs == 0: 
            if verbose > 1: 
                print_flush(f"[ Get Encoder Embeddings Ensure Batch Size ] Using value 64 as 0 is not a valid value.", verbose = verbose)
            enc_learn.dls.bs = 64
        elif verbose > 1: 
            print_flush(f"[ Get Encoder Embeddings Ensure Batch Size ] Using the original value: {dls.bs}", verbose = verbose)
    else:
        dls.bs = batch_size
        if verbose > 1: 
            print_flush(f"[ Get Encoder Embeddings Ensure Batch Size ] Batch size proposed. Using {dls.bs}", verbose = verbose)

# %% ../nbs/encoder.ipynb 22
def get_enc_embs_MVP(
    X               : List [ List [ List [ float ] ] ], 
    enc_learn       : Learner, 
    module          : str  = None, 
    cpu             : bool = False, 
    average_seq_dim : bool = True, 
    to_numpy        : bool = True,
    batch_size      : int  = None,
    verbose         : int  = 0
):
    """
        Get the embeddings of X from an encoder, passed in `enc_learn as a fastai
        learner. By default, the embeddings are obtained from the last layer
        before the model head, although any layer can be passed to `model`.
        Input
        - `cpu`: Whether to do the model inference in cpu of gpu (GPU recommended)
        - `average_seq_dim`: Whether to aggregate the embeddings in the sequence dimensions
        - `to_numpy`: Whether to return the result as a numpy array (if false returns a tensor)
        - `batch_size`: force data loader to use the input batch size
        - `verbose`: print flag. More big, more information.
    """
    
    if cpu:
        if verbose > 0: print_flush("[ Get Encoder Embeddings ] CPU")
        enc_learn.dls.cpu()
        enc_learn.cpu()
    else:
        if verbose > 0: print_flush("[ Get Encoder Embeddings ] --> GPU")
        if verbose > 1: print_flush("[ Get Encoder Embeddings ] GPU | Ensure empty cache")
        torch.cuda.empty_cache()
        if verbose > 1: print_flush("[ Get Encoder Embeddings ] GPU | Move & exec into CUDA")
        enc_learn.dls.cuda()
        enc_learn.cuda()
        if torch.cuda.is_available():
            if verbose > 1: 
                print_flush("[ Get Encoder Embeddings ] GPU | CUDA is available")
                print_flush(f"[ Get Encoder Embeddings ] GPU | CUDA is available | current device id {torch.cuda.current_device()}")
                print_flush(f"[ Get Encoder Embeddings ] GPU | CUDA is available | current device name {torch.cuda.get_device_name(torch.cuda.current_device())}")            
        else:
            if verbose > 1: print_flush("[ Get Encoder Embeddings ] GPU | CUDA is not available")
        if verbose > 0: print_flush("[ Get Encoder Embeddings ] GPU -->")

    #if verbose > 0: print_flush("[ Get Encoder Embeddings ] Ensure the correct batch size")
    #get_enc_embs_ensure_batch_size_(enc_learn.dls, batch_size, verbose)
    
    if verbose > 0: print_flush("[ Get Encoder Embeddings ] Set dataloader from X (enc_learn does not contain dls)")
    aux_dl = enc_learn.dls.valid.new_dl(X=X)
    get_enc_embs_ensure_batch_size_(aux_dl, batch_size, verbose)
    if verbose > 0: print_flush("[ Get Encoder Embeddings ] Get module")
    module = nested_attr(enc_learn.model,ENCODER_EMBS_MODULE_NAME[type(enc_learn.model)]) if module is None else module
    
    if verbose > 0: print_flush("[ Get Encoder Embeddings ] get_acts_and_grads ")
    if verbose > 1: print_flush(f"[ Get Encoder Embeddings ] get_acts_and_grads bs = {aux_dl.bs}")
    
    embs = [
        get_acts_and_grads(
            model   = enc_learn.model,
            modules = module,
            x       = xb[0], 
            cpu     = cpu
        )[0] 
        for xb in aux_dl
    ]
    if verbose > 0: print_flush("[ Get Encoder Embeddings ] get_acts_and_grads | --> Concat")
    if not cpu:
        if verbose > 1: print_flush("[ Get Encoder Embeddings ] get_acts_and_grads | Concat | Check neccesary & free memory")
        total_emb_size = sum([emb.element_size() * emb.nelement() for emb in embs])
        free_memory = torch.cuda.get_device_properties(0).total_memory - torch.cuda.memory_allocated()
        if (total_emb_size < free_memory):
            if verbose > 1: print_flush("[ Get Encoder Embeddings ] get_acts_and_grads | Concat | Check neccesary & free memory | Fits in GPU -> Computing in GPU")
            embs=[emb.cuda() for emb in embs]
        else:
            if verbose > 1: print_flush("[ Get Encoder Embeddings ] get_acts_and_grads | Concat | Check neccesary & free memory | Does not fit in GPU -> Computing in CPU")
            embs=[emb.cpu() for emb in embs]
    if verbose > 1: print_flush("[ Get Encoder Embeddings ] get_acts_and_grads | Concat | to_concat")
    embs = to_concat(embs)
    if verbose > 0: print_flush("[ Get Encoder Embeddings ] get_acts_and_grads | Concat -->")
    
    if verbose > 0: print_flush("[ Get Encoder Embeddings ] Reduce to 2 dimensions.")
    if embs.ndim == 3 and average_seq_dim: embs = embs.mean(axis=2)
    if verbose > 0: print_flush("[ Get Encoder Embeddings ] Ensure CPU saving & numpy format")
    if to_numpy: embs = embs.numpy() if cpu else embs.cpu().numpy()
    return embs

# %% ../nbs/encoder.ipynb 23
def get_enc_embs_MVP_set_stride_set_batch_size(
    X                  : List [ List [ List [ float ] ] ], 
    enc_learn          : Learner, 
    stride             : int, 
    batch_size         : int, 
    module             : str  = None, 
    cpu                : bool = False, 
    average_seq_dim    : bool = True, 
    to_numpy           : bool = True, 
    verbose            : int  = 0, 
    time_flag          : bool = False, 
    chunk_size         : int  = 0, 
    check_memory_usage : bool = False
):
    """
        Get the embeddings of X from an encoder, passed in `enc_learn as a fastai
        learner. By default, the embeddings are obtained from the last layer
        before the model head, although any layer can be passed to `model`.
        Input
        - `X`: encoder input
        - `enc_learn`: trained encoder
        - `stride`: stride used for the training. Neccesary for adjusting the encoder input
        - `batch_size`: value to force the dataloader to use.
        - `module`: for geting the embeddings of an specific layer.
        - `cpu`: Whether to do the model inference in cpu of gpu (GPU recommended)
        - `average_seq_dim`: Whether to aggregate the embeddings in the sequence dimensions
        - `to_numpy`: Whether to return the result as a numpy array (if false returns a tensor)
        - `verbose`: For printing messages. More big, more messages.
        - `time_flag`: To take note of the execution time required by this function
        - `chunk_size`: For spliting the embedings reading in batches of `chunk_size` size.
        - `check_memory_usage`: For showing messages of the current state of the memory.
    """
    if time_flag:
        t_start = time.time()
    if verbose > 0:
        print_flush("--> get_enc_embs_MVP_set_stride_set_batch_size", verbose = verbose)
    if check_memory_usage: gpu_memory_status()
    X = X[::stride]
    enc_learn.dls.bs = batch_size 

    get_enc_embs_ensure_batch_size_(enc_learn.dls, batch_size, verbose)
    
    if verbose > 0: print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Check CUDA | X ~ {X.shape[0]}", verbose = verbose)
    if cpu:
        if verbose > 0: print_flush("get_enc_embs_MVP_set_stride_set_batch_size | Get enc embs CPU")
        enc_learn.dls.cpu()
        enc_learn.cpu()
    else:
        if torch.cuda.is_available():
            if verbose > 0: 
                print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | CUDA device id: {torch.cuda.current_device()}", verbose = verbose)
                print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | CUDA device name: {torch.cuda.get_device_name(torch.cuda.current_device())}", verbose = verbose)
                print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Ensure empty cache & move 2 GPU", verbose = verbose)
            torch.cuda.empty_cache()
            enc_learn.dls.cuda()
            enc_learn.cuda()
        else:
            if verbose > 0: print_flush("get_enc_embs_MVP_set_stride_set_batch_size | No cuda available. Set CPU = true")
            cpu = True
            
    get_enc_embs_ensure_batch_size_(enc_learn.dls, batch_size, verbose)

    if verbose > 0: print_flush("get_enc_embs_MVP_set_stride_set_batch_size | Set dataset from X (enc_learn does not contain dls)", verbose = verbose)
    aux_dl = enc_learn.dls.valid.new_dl(X=X)
    aux_dl.bs = enc_learn.dls.bs if enc_learn.dls.bs>0 else 64
    if verbose > 0: print_flush("get_enc_embs_MVP_set_stride_set_batch_size | Get module", verbose = verbose)
    module = nested_attr(enc_learn.model,ENCODER_EMBS_MODULE_NAME[type(enc_learn.model)]) if module is None else module
    
    if verbose > 0: 
        #print_flush("get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | module ", module)
        print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | aux_dl len {len(aux_dl)}", verbose = verbose)
        print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | aux_dl.batch_len {len(next(iter(aux_dl)))}", verbose = verbose)
        print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | aux_dl.bs {aux_dl.bs}", verbose = verbose)
        if (not cpu):
            total = torch.cuda.get_device_properties(device).total_memory
            used = torch.cuda.memory_allocated(torch.cuda.current_device())
            reserved = torch.cuda.memory_reserved(torch.cuda.current_device())
            print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | total_mem {total}", verbose = verbose)
            print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | used_mem {used}", verbose = verbose)
            print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | reserved_mem {reserved}" ,verbose = verbose)
            print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | available_mem {total-reserved}", verbose = verbose)
            sys.stdout.flush()
                                              
    if (cpu or ( chunk_size == 0 )):
        embs = [
            get_acts_and_grads(
                model=enc_learn.model,
                modules=module, 
                x=xb[0], 
                cpu=cpu
            )[0] 
            for xb in aux_dl
        ]
        if not cpu: embs=[emb.cpu() for emb in embs]
    else:
        embs = []
        total_chunks=max(1,round(len(X)/chunk_size))
        if verbose > 0: print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | aux_dl len | {str(len(X))}  chunk size: {str(chunk_size) } => { str(total_chunks) }  chunks", verbose = verbose)
        for i in range(0, total_chunks):
            if verbose > 0: 
                print_flush(f"get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | Chunk [ {str(i)}/{str(total_chunks)}] => {str(round(i*100/total_chunks))}%", verbose = verbose)
                sys.stdout.flush()
            chunk = [batch for (n, batch) in enumerate(aux_dl) if (chunk_size*i <= n  and chunk_size*(i+1) > n) ]
            chunk_embs = [
                get_acts_and_grads(
                    model=enc_learn.model,
                    modules=module,
                    x=xb[0], 
                    cpu=cpu
                )[0]
                for xb in chunk
            ]
            # Mueve los embeddings del bloque a la CPU
            chunk_embs = [emb.cpu() for emb in chunk_embs]
            embs.extend(chunk_embs)
            torch.cuda.empty_cache()
        if verbose > 0: 
            print_flush("get_enc_embs_MVP_set_stride_set_batch_size | Get acts and grads | 100%", verbose = verbose)
            sys.stdout.flush()
    
    if verbose > 0: print_flush("get_enc_embs_MVP_set_stride_set_batch_size | concat embeddings", verbose = verbose)
    
    embs = to_concat(embs)
    
    if verbose > 0: print_flush("get_enc_embs_MVP_set_stride_set_batch_size | Reduce", verbose = verbose)
    
    if embs.ndim == 3 and average_seq_dim: embs = embs.mean(axis=2)
    
    if verbose > 0: print_flush("get_enc_embs_MVP_set_stride_set_batch_size | Convert to numpy", verbose = verbose)
    
    if to_numpy: 
        if cpu or chunk_size > 0:
            embs = embs.numpy() 
        else: 
            embs = embs.cpu().numpy()
            torch.cuda.empty_cache()
    if time_flag:
        t = time.time()-t_start
        if verbose > 0:
            print_flush("get_enc_embs_MVP_set_stride_set_batch_size " + str(t) + " seconds -->", verbose = verbose)
        else:
            print_flush("get_enc_embs_MVP_set_stride_set_batch_size " + str(t) + " seconds", verbose = verbose)
    if check_memory_usage: gpu_memory_status()
    if verbose > 0: 
        print_flush("get_enc_embs_MVP_set_stride_set_batch_size -->", verbose = verbose)
    return embs

# %% ../nbs/encoder.ipynb 24
def get_enc_embs_moment(
    X               : List [ List [ List [ float ] ] ], 
    enc_learn       : Learner, 
    cpu             : bool = False, 
    to_numpy        : bool = True,
    verbose         : int  = 0,
    average_seq_dim : bool = True
):
    if verbose > 0: 
        print_flush("--> get_enc_embs_moment", verbose = verbose)
    # Move tensor and model to GPU
    if cpu or not torch.cuda.is_available():
        if verbose > 0: 
            print_flush("get_enc_embs_moment | Using CPU (maybe no cuda available)", verbose = verbose)
        cpu = True
        enc_learn.cpu()
    else:
        if verbose > 0: 
            print_flush("get_enc_embs_moment | Using CUDA", verbose = verbose)
        enc_learn.to("cuda")
    if verbose > 0: print_flush("get_enc_embs_moment | Convert y", verbose = verbose)
    enc_learn.eval()
    if cpu:
        y = torch.from_numpy(X).cpu().float()
    else:
        y = torch.from_numpy(X).to("cuda").float()
    # Get output
    with torch.no_grad():
        if verbose > 0: 
            print_flush("get_enc_embs_moment | Get outputs", verbose = verbose)
        outputs = enc_learn(y)
        if verbose > 0:
            print_flush(f"get_enc_embs_moment | Final shape: X ~ {y.shape}", verbose = verbose)
                
    #| move tensors and models back to CPU
    if not cpu:
        y = y.detach().cpu().numpy()
    if verbose > 0: 
        print_flush("get_enc_embs_moment | Get Embeddings", verbose = verbose)
    embeddings = outputs.embeddings.detach().cpu()
    if average_seq_dim: 
        embeddings = embeddings.mean(dim = 1)
    if to_numpy:
        embeddings = embeddings.cpu().numpy()
    if verbose > 0: 
        print_flush("get_enc_embs_moment -->", verbose = verbose)
    return embeddings

# %% ../nbs/encoder.ipynb 25
def get_enc_embs_moment_reconstruction(
    X               : List [ List [ List [ float ] ] ], 
    enc_learn       : Learner, 
    cpu             : bool          = False, 
    to_numpy        : bool          = True,
    verbose         : int           = 0,
    average_seq_dim : bool          = True,
    padd_step       : int           = 2,
    #- Printing options for debugging
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a',
    continue_if_fail: bool          = False
):
    """
    For reconstruction sometimes mask get invalid values
    To avoid them, the last dimension (sequence length) is padded with 0's until the error is skippedd
    It should only get one iteration as it seems to be some MOMENT internal configuration for patches.
    """
    if cpu:
        enc_learn.cpu()
        y = torch.from_numpy(X).cpu().float()
    else:
        enc_learn.to("cuda")
        y = torch.from_numpy(X).to("cuda").float()
    embs = get_acts_moment(
        enc_learn       = enc_learn, 
        cpu             = cpu, 
        verbose         = verbose, 
        y               = y, 
        mask            = None,
        padd_step       = padd_step,
        retry           = False ,
        max_trials      = 5,
        print_to_path   = print_to_path, print_path = print_path, print_mode = print_mode
    )
    if average_seq_dim: 
        embs = embs.mean(dim = 1).mean(dim = 1)
    if to_numpy:
        embs = embs.cpu().numpy()
    return embs

# %% ../nbs/encoder.ipynb 27
import uni2ts.model.moirai.module as moirai
import uni2ts.model.moirai.forecast as moirai_forecast

# %% ../nbs/encoder.ipynb 28
import torch.profiler as profiler

# %% ../nbs/encoder.ipynb 29
def watch_gpu(func, **kwargs):
    """
    Wrapper to execute GPU profiler
    Parameters: 
    - func: function to monitor
    - kwargs: func parameters
    Returns:
    - result of /func/.
    """
    with profiler.profile(
        activities=[profiler.ProfilerActivity.CPU, profiler.ProfilerActivity.CUDA],
        schedule=profiler.schedule(wait=1, warmup=1, active=3, repeat=2),  # Configuración de ciclos
        on_trace_ready=profiler.tensorboard_trace_handler('./log_dir'),  # Guarda los resultados en un archivo para visualización
        record_shapes=True,  # Registra la forma de los tensores
        profile_memory=True,  # Perfil de memoria
        with_stack=True  # Incluye la información de la pila
    ) as prof:
        # Ejecuta la función dentro del perfilador
        result = func(**kwargs)
    
    # Mostrar el uso de la GPU durante y después de la ejecución
    print_flush(prof.key_averages().table(sort_by="cuda_memory_usage", row_limit=10))
    return result

# %% ../nbs/encoder.ipynb 30
def get_enc_embs_moirai(
    enc_input       : List [ List [ List [ Float ] ] ], 
    enc_model       : moirai.MoiraiModule, 
    cpu             : False,
    average_seq_dim : bool = True, 
    verbose         : int  = 0,
    to_numpy        : bool = True,
    patch_size      : int  = 8,
    time            : bool = False
):
    if time: 
        timer = Time()
        timer.start()
    if verbose > 0: 
        print_flush("--> get_enc_embs_moirai", verbose = verbose)
    # Move tensor and model to GPU
    past_target = einops.rearrange(
        torch.as_tensor(enc_input, dtype = torch.float32),
        "n_windows n_vars window_size -> n_windows window_size n_vars"
    )
    if cpu or not torch.cuda.is_available():
        if verbose > 0: print_flush("get_enc_embs_moirai | Using CPU (maybe no cuda available)", verbose = verbose)
        cpu = True
        enc_model.cpu()
        past_target.cpu()
    else:
        if verbose > 0: print_flush("get_enc_embs_moirai | Using CUDA", verbose = verbose)
        enc_model.to("cuda")
        past_target.to("cuda")
        
    if verbose > 0: print_flush("get_enc_embs_moirai | Get Outputs", verbose = verbose)

    
    past_observed_target = torch.ones_like(past_target, dtype=torch.bool)
    past_is_pad = torch.zeros_like(past_target, dtype=torch.bool)[...,:,-1] # Kill last dimension

    if (verbose > 1):
        print_flush(f"--> get_enc_embs_moirai | past_target ~ {past_target.shape}")
        print_flush(f"--> get_enc_embs_moirai | past_observed_target ~ {past_observed_target.shape}")
        print_flush(f"--> get_enc_embs_moirai | past_is_pad ~ {past_is_pad.shape}")
        print_flush(f"--> get_enc_embs_moirai | Auxiliar model")
        print_flush(f"--> get_enc_embs_moirai | Auxiliar model | Before Memory:")
        gpu_memory_status()
    
    # Auxiliar model for conversions just to ensure correct sizes
    #not neccesary, is the same module initially downloaded...
    #module = moirai.MoiraiModule.from_pretrained(f"Salesforce/moirai-1.1-R-small")
    
    forecast_model =  moirai_forecast.MoiraiForecast(
        module=enc_model,
        prediction_length=past_target.shape[2], #random, just for getting the model
        context_length=past_target.shape[1],
        patch_size=patch_size,
        num_samples=100, #Random, is the number of forecasting, not interesting for us
        target_dim=past_target.shape[2],
        feat_dynamic_real_dim=0,
        past_feat_dynamic_real_dim=0,
    )
    
    if verbose > 0:
        print_flush(f"--> get_enc_embs_moirai | Auxiliar model | After Memory:")
        gpu_memory_status()
        print_flush(f"--> get_enc_embs_moirai | Convert sizes")
    (
    target,
    observed_mask,
    sample_id,
    time_id,
    variate_id,
    prediction_mask,
    ) = forecast_model._convert(
        patch_size,
        past_target,
        past_observed_target,
        past_is_pad
    )
    if verbose > 1:
        print_flush(f"get_enc_embs_moirai | target ~ {target.shape}")
        print_flush(f"get_enc_embs_moirai | observed_mask ~ {observed_mask.shape}")
        print_flush(f"get_enc_embs_moirai | sample_id ~ {sample_id.shape}")
        print_flush(f"get_enc_embs_moirai | time_id ~ {time_id.shape}")
        print_flush(f"get_enc_embs_moirai | variate_id ~ {variate_id.shape}")
        print_flush(f"get_enc_embs_moirai | prediction_mask ~ {prediction_mask.shape}")
        gpu_memory_status()
    forecast_model = None
    torch.cuda.empty_cache()
    if verbose > 0:
        print_flush(f"--> get_enc_embs_moirai | Delete Auxiliar model | After Memory:")
        gpu_memory_status()
    
    model_kwargs={
        'target': target, 
        'observed_mask': observed_mask,
        'sample_id': sample_id,
        'time_id': time_id,
        'variate_id': variate_id,
        'prediction_mask': prediction_mask,
        'patch_size': torch.ones_like(sample_id, dtype = torch.float32)*patch_size
    } 
    if verbose > 0: 
        print_flush(f"get_enc_embs_moirai | About to get activations")
    acts = get_acts(
        model  = enc_model, 
        module = enc_model.encoder.norm, 
        cpu    = cpu,
        verbose = verbose,
        retry = True,
        acts_indices = [0],
        **model_kwargs #Parameters of the model
    )
    
    embs = acts
    acts = None
    if average_seq_dim :
        if verbose > 0: 
            print_flush(f"get_enc_embs_moirai | About to reduce activations", verbose = verbose)
        embs = embs.mean(dim = 1)
    
    if not cpu:
        #print_flush(f"get_enc_embs_moirai | enc_input to cpu")
        #enc_input.cpu()
        print_flush(f"get_enc_embs_moirai | enc_model to cpu", verbose = verbose)
        enc_model.cpu()
        print_flush(f"get_enc_embs_moirai | torch cuda empty cache", verbose = verbose)
        torch.cuda.empty_cache()
    if to_numpy: 
        if cpu > 0:
            embs = embs.numpy() 
        else: 
            embs = embs.cpu().numpy()
            torch.cuda.empty_cache()
    if verbose > 0: 
        print_flush(f"get_enc_embs_moirai | embs ~ {embs.shape}", verbose = verbose)
        print_flush("get_enc_embs_moirai -->", verbose = verbose)
    return embs

# %% ../nbs/encoder.ipynb 32
def get_enc_embs(
    X               , 
    enc_learn       : Learner, 
    module          : str  = None, 
    cpu             : bool = False, 
    average_seq_dim : bool = True, 
    to_numpy        : bool = True,
    verbose         : int  = 0,
    **kwargs        
):
    embs = None
    enc_learn_class = str(enc_learn.__class__)[8:-2]
    match enc_learn_class:
        case "momentfm.models.moment.MOMENTPipeline":
            match enc_learn.task_name:
                case "embedding":
                    embs = get_enc_embs_moment(X, enc_learn, cpu, to_numpy, verbose, average_seq_dim, **kwargs)
                case "reconstruction":
                    embs = get_enc_embs_moment_reconstruction(X, enc_learn, cpu, to_numpy, verbose, average_seq_dim, **kwargs)
                case _:
                    print_flush(f"Model embeddings for moment-{enc_learn.task_name} is not yet implemented.", verbose = verbose)
        case "fastai.learner.Learner":
            embs = get_enc_embs_MVP_set_stride_set_batch_size(X, enc_learn, stride, batch_size, module, cpu, average_seq_dim, to_numpy, verbose, False, 0, False)
        case "uni2ts.model.moirai.module.MoiraiModule":
            embs = get_enc_embs_moirai(
                enc_input  = X, 
                enc_model  = enc_learn,
                cpu        = cpu, 
                average_seq_dim = average_seq_dim,
                verbose    = verbose,
                **kwargs
            )
        case _:
            print_flush(f"Model embeddings implementation is not yet implemented for {enc_learn_class}.", verbose = verbose)
    return embs

# %% ../nbs/encoder.ipynb 33
def get_enc_embs_set_stride_set_batch_size(
    X                  : List [ List [ List [ float ] ] ], 
    enc_learn          : Learner, 
    stride             : int, 
    batch_size         : int, 
    module             : str  = None, 
    cpu                : bool = False, 
    average_seq_dim    : bool = True, 
    to_numpy           : bool = True, 
    verbose            : int  = 0, 
    time_flag          : bool = False, 
    chunk_size         : int  = 0, 
    check_memory_usage : bool = False,
    **kwargs
):
    print_flush("--> get_enc_embs_set_stride_set_batch_size", verbose = verbose)
    embs = None
    enc_learn_class = str(enc_learn.__class__)[8:-2]
    match enc_learn_class:
        case "momentfm.models.moment.MOMENTPipeline":
            if verbose > 0: 
                print_flush(f"get_enc_embs_set_stride_set_batch_size | Moment | {average_seq_dim}", verbose = verbose)
            match enc_learn.task_name:
                case "embedding":
                    embs = get_enc_embs_moment( X = X, enc_learn = enc_learn, cpu = cpu, to_numpy = to_numpy, verbose = verbose, average_seq_dim = average_seq_dim)
                case "reconstruction":
                    embs = get_enc_embs_moment_reconstruction(X= X, enc_learn = enc_learn, cpu = cpu, to_numpy = to_numpy, verbose = verbose, average_seq_dim = average_seq_dim, **kwargs)
                case _:
                    print_flush(f"Model embeddings for moment-{enc_learn.task_name} is not yet implemented.", verbose = verbose)
        case "fastai.learner.Learner":
            if verbose > 0: 
                print_flush(f"get_enc_embs_set_stride_set_batch_size | MVP | {average_seq_dim}", verbose = verbose)
            if verbose > 1:
                print_flush(f"get_enc_embs_set_stride_set_batch_size | X ~{X.shape}", verbose = verbose)
            embs = get_enc_embs_MVP_set_stride_set_batch_size(
                X = X, 
                enc_learn = enc_learn, 
                stride = stride, 
                batch_size = batch_size, 
                module = module, 
                cpu = cpu, 
                average_seq_dim = average_seq_dim,
                to_numpy = to_numpy, 
                verbose = verbose, 
                time_flag = time_flag, 
                chunk_size = chunk_size, 
                check_memory_usage = check_memory_usage
            )
        case "uni2ts.model.moirai.module.MoiraiModule":
            if verbose > 0: 
                print_flush(f"get_enc_embs_set_stride_set_batch_size | Moirai | {average_seq_dim}", verbose = verbose)
            embs = get_enc_embs_moirai(
                enc_input  = X, 
                enc_model  = enc_learn,
                cpu        = cpu, 
                average_seq_dim = average_seq_dim,
                verbose    = verbose,
                to_numpy = to_numpy,
                **kwargs
            )
        case _:
            print_flush(f"[ get_enc_embs_set_stride_set_batch_size ] Model embeddings implementation is not yet implemented for {enc_learn_class}.", verbose = verbose)
    # Ñapa: TODO: Gestionar que no se queden en memoria los modelos porque ocupan el 40% de la GPU al llamarlos desde R
    if verbose > 0: print_flush(f"get_enc_embs_set_stride_set_batch_size | Before moving to CPU | embs~{embs.shape}", verbose = verbose)
    if cpu:
        #X.cpu()
        enc_learn.cpu()
        try: 
            enc_lear.dls.cpu()
        except Exception as e: 
            print_flush(f"get_enc_embs_set_stride_set_batch_size | Exception: {e}", verbose = verbose)
        #kwargs_to_cpu_(**kwargs)
    if verbose > 0: print_flush(f"get_enc_embs_set_stride_set_batch_size | embs~{embs.shape} -->", verbose = verbose)
    return embs

# %% ../nbs/encoder.ipynb 36
from tqdm.auto import tqdm
from transformers import get_scheduler
import evaluate
from torch.nn.modules.loss import _Loss
from tsai.data.preparation import SlidingWindow
from .utils import find_dominant_window_sizes_list
from .config import show_attrdict

# %% ../nbs/encoder.ipynb 37
def random_windows(
    X : List [ List [ List [ float ]]], 
    n_windows   = None, 
    percent     = None, 
    verbose     = 0,
    #- Printing options for debugging
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a'
):
    """
    Parameters: 
    - X: Numpy array of windows. Expected shape: [batch_size or n_samples, n_vars, window_len]
    Given a numpy array of windows, selects:
    - n_windows random windows from the array, if n_windows is given.
    - ceil(percent*len(X)) random windows otherwise
    """
    if verbose > 0: print_flush(f"--> Random windows: {n_windows}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    if n_windows is None and percent is None:
        windows = torch.from_numpy(X)
    else: 
        n_windows = int(min(X.shape[0], n_windows) if n_windows is not None else np.ceil(percent*X.shape[0]))
        if verbose > 0: print_flush(f"Random windows | n_windows: {n_windows}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        random_indices = np.random.randint(0, int(X.shape[0]), n_windows)
        windows = X[ random_indices ]
        windows = torch.from_numpy(windows)
    if verbose > 0: print_flush(f"Random windows | windows ~ {windows.shape} | -->", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    return windows

# %% ../nbs/encoder.ipynb 38
def windowed_dataset(
    X                               : Union [ List [ List [ List [ float ]]], List [ float ], pd.DataFrame ],
    stride                          : int           = 1,
    window_sizes                    : List [int]    = None,
    n_window_sizes                  : int           = 1,
    window_sizes_offset             : int           = 0.05,
    windows_min_distance            : int           = 1,
    full_dataset                    : bool          = False,
    mssg                            : Mssg          = Mssg()
): 
    if mssg.verbose > 0: mssg.print("--> windowed_dataset")
    dss = []
    if isinstance(X, list):
        if mssg.verbose > 0: mssg.print("windowed_dataset | X is a list. Converting to dataFrame")
        X = np.array(X)
        X = pd.DataFrame(X)        
    if ( isinstance(X,pd.DataFrame) or full_dataset): 
        if mssg.verbose > 0: mssg.print("windowed_dataset | X is a DataFrame")
        if window_sizes is None or n_window_sizes > len(window_sizes):
            if mssg.verbose > 0: mssg.print("windowed_dataset | X is a DataFrame | Selecting Fourier's dominant frequences")
            # Select Fourier's dominant frequences
            window_sizes_ = find_dominant_window_sizes_list(
                X               = X, 
                nsizes          = n_window_sizes, 
                offset          = window_sizes_offset, 
                min_distance    = windows_min_distance,
                verbose         = mssg.verbose-1,
                print_to_path   = mssg.to_path, print_path = mssg.path, print_mode = mssg.mode
            )
            window_sizes = window_sizes_ if window_sizes is None else list(set(window_sizes + window_sizes_))[:n_window_sizes]
            if mssg.verbose > 0: mssg.print(f"windowed dataset | X is a DataFrame | Selecting Fourier's dominant frequences | {window_sizes}")
        if mssg.verbose > 0: mssg.print(f"windowed dataset | Building the datasets")
        for w in window_sizes:
            enc_input, _ = SlidingWindow(window_len = w, stride = stride, get_y=[])(X)
            dss.append(enc_input)
    else: 
        if mssg.verbose > 0: mssg.print("windowed_dataset | X is already windowed")
        dss = [X]
    return dss


# %% ../nbs/encoder.ipynb 39
def setup_scheduler(
    dl_train                        : DataLoader,
    lr_scheduler_flag               : bool= False,
    lr_scheduler_name               : str = "",
    optimizer                             = None,
    num_epochs                      : int = 10,
    lr_scheduler_num_warmup_steps   : int = None,
    num_training_steps              : int = None,
    lr_scheduler_perc_warmup_steps  : int = 0.02,
    lr_scheduler_max_lr             : float = None,
    lr                              : float = 1e-4
):
    num_training_steps = num_epochs * len(dl_train) if num_training_steps is None else num_training_steps
    lr_scheduler_num_warmup_steps = lr_scheduler_perc_warmup_steps*num_training_steps
    lr_scheduler_max_lr = 5 - 10 * lr if lr_scheduler_max_lr is None else lr_scheduler_max_lr
    if lr_scheduler_flag:
        match lr_scheduler_name:
            case "OneCycleLR": 
                lr_scheduler = torch.optim.lr_scheduler.OneCycleLR(
                    optimizer           = optimizer,
                    max_lr              = lr_scheduler_max_lr,
                    epochs              = num_epochs,
                    steps_per_epoch     = len(dl_train)
                )
            case _:
                lr_scheduler = get_scheduler(
                    name                = lr_scheduler_name,
                    optimizer           = optimizer,
                    num_warmup_steps    = lr_scheduler_num_warmup_steps,
                    num_training_steps  = num_training_steps
                )
    return lr_scheduler

# %% ../nbs/encoder.ipynb 40
def prepare_train_and_eval_dataloaders(
    X                   : Union [ List [ List [ List [ float ]]], List [ float ], pd.DataFrame ],
    batch_size          : int,
    n_windows           : int   = None,
    n_windows_percent   : int   = None,
    training_percent    : int   = 0.4,
    validation_percent  : int   = 0.3,
    shot                : bool  = False,
    eval_pre            : bool  = False,
    eval_post           : bool  = False,
    #- Printing options for debugging
    print_to_path       : bool  = False,
    print_path          : str   = "~/data/logs/logs.txt",
    print_mode          : str   = 'a',
    verbose             : int   = 0
):
    dl_eval  = None
    ds_train = None,
    dl_train = None
    if n_windows is None and n_windows_percent is None:
        train_split_index = min(X.shape[0], np.ceil(training_percent * X.shape[0]))
        eval_split_index = min(X.shape[0], np.ceil(validation_percent * X.shape[0]))
    else:
        train_split_index = min(X.shape[0], np.ceil(training_percent * n_windows)) if n_windows is not None else np.ceil(training_percent * n_windows_percent * X.shape[0])
        eval_split_index = min(X.shape[0], np.ceil(validation_percent * n_windows)) if n_windows is not None else np.ceil(validation_percent * n_windows_percent * X.shape[0])
    
    train_split_index = int(train_split_index)
    eval_split_index = int(eval_split_index)
    if shot: 
        if verbose > 0: 
            print_flush(f"fine_tune_moment_single | Selecting ds train | {train_split_index} windows", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
        ds_train = X[:train_split_index]
    if eval_pre or eval_post: 
        if verbose > 0: 
            print_flush(f"fine_tune_moment_single | Selecting validation train | {eval_split_index} windows", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        ds_test  = torch.from_numpy(X[:eval_split_index]).float()
    # -- Select only the small percentage for few-shot
    if shot:
        if verbose > 0: 
            print_flush("fine_tune_moment_single | Train DataLoader | Random windows", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        ds_train = random_windows(ds_train, n_windows, n_windows_percent, verbose-1, print_to_path = print_to_path, print_path = print_path, print_mode = 'a')
        ds_train = ds_train.float()
        # Create the dataloader
        if verbose > 0: 
            print_flush("fine_tune_moment_single | Train DataLoader | DataLoader", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        dl_train = DataLoader(ds_train, batch_size = batch_size, shuffle = True)
    if eval_pre or eval_post: 
        if verbose > 0: 
            print_flush("fine_tune_moment_single | Validation DataLoader", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        dl_eval  = DataLoader(ds_test, batch_size = batch_size, shuffle = False)
    return dl_eval, dl_train, ds_train

# %% ../nbs/encoder.ipynb 42
from momentfm.utils.masking import Masking

# %% ../nbs/encoder.ipynb 43
def fine_tune_moment_compute_loss_check_sizes_(
    batch           : List [ List [ List [ float ] ] ], 
    output, 
    verbose         : int   = 0,
    # Print options
    print_to_path   : bool  = False,
    print_path      : str   = "~/data/logs/logs.txt",
    print_mode      : str   = 'a'
):
    if verbose > 0: print_flush("--> fine_tune_moment_compute_loss_check_sizes_", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    b = batch.clone()
    b_2 = batch.shape[2]
    re_2 = output.reconstruction.shape[2]
    if b_2 > re_2:
        if verbose > 0: print_flush(f" Fine tune loop | TODO: Why? Original {b_2} > {re_2}  Reconstruction", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        b = b[...,:re_2]
    elif re_2 > b_2:
        if verbose > 1: print_flush(f" Fine tune loop | Why ? Original {b_2} < {re_2} Reconstruction ? Padding", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        output.reconstruction = output.reconstruction[...,:b_2]
    else: 
        if verbose > 1: print_flush(f" Fine tune loop | re_2 {re_2} == {b_2} y_2", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    if verbose > 1: 
        print_flush(f"---------- Checking loss  ------- | reconstruction ~ {output.reconstruction.shape} | original_ ~ {b.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    if verbose > 0: print_flush("fine_tune_moment_compute_loss_check_sizes_ -->", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    return b

# %% ../nbs/encoder.ipynb 44
def fine_tune_moment_compute_loss(
    batch, 
    output, 
    criterion   = torch.nn.MSELoss, 
    verbose     = 0, 
    input_mask  = None, 
    mask        = None,
    # Print options
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a'
):
    if verbose > 0: print_flush("--> fine_tune_moment_compute_loss", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    b = fine_tune_moment_compute_loss_check_sizes_(batch = batch, output = output, verbose = verbose, print_to_path = print_to_path, print_path = print_path, print_mode = 'a')
    if verbose > 0: print_flush(f"fine_tune_moment_compute_loss | b~{b.shape} | o~{output.reconstruction.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    o = output.reconstruction
    device = b.device if b.device != "cpu" else o.device
    b = b.to(device)
    o = o.to(device)
    compute_loss = criterion()
    recon_loss = compute_loss(o, b)
    batch_masks = output.input_mask if input_mask is None else input_mask
    mask = output.pretrain_mask if mask is None else mask
    batch_masks = batch_masks.to(device)
    mask = mask.to(device)
    if verbose > 1: print_flush(f"fine_tune_moment_compute_loss | batch ~ {b.shape} | {b.device}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    if verbose > 1: print_flush(f"fine_tune_moment_compute_loss | batch_masks ~ {batch_masks.shape} | {batch_masks.device}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    if verbose > 1: print_flush(f"fine_tune_moment_compute_loss | mask ~ {mask.shape} | {mask.device}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    
    observed_mask = batch_masks * (1-mask)
    masked_loss = observed_mask * recon_loss
    loss = masked_loss.nansum() / (observed_mask.nansum() + 1e-7)
    if verbose > 2: print_flush(f"Loss type: {type(loss)}",print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)  # Debe ser <class 'torch.Tensor'>
    if verbose > 1: print_flush(f"fine_tune_moment_compute_loss | loss: {loss.item()}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    if verbose > 0: print_flush("fine_tune_moment_compute_loss -->", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    return loss

# %% ../nbs/encoder.ipynb 45
def fine_tune_moment_eval_preprocess(
    predictions : List [ List [ float ]],
    references : List [ List [ float ]],
    verbose : int = 0,
    # Print options
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a'
):
    """
    Parameters:
    - predictions torch (float)
    - references torch (float)
    Returns: 
        - Predictions and references ensuring same shape and no NaN values. 
        - Uses the shape of the smallest torch for the modification.
    """
    if verbose > 0: 
        print_flush(f"fine_tune_moment_eval | Before reshape | preds~{predictions.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)            
        print_flush(f"fine_tune_moment_eval | Before reshape | refs~{references.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    predictions = einops.rearrange(predictions, "b v w -> (b v) w")
    references = einops.rearrange(references, "b v w -> (b v) w")
    # Avoid NaN 
    if predictions.shape[1] > references.shape[1]: predictions = predictions[:,:references.shape[1]]
    if predictions.shape[1] < references.shape[1]: references = references[:,:predictions.shape[1]]
    if verbose > 0: 
        print_flush(f"Eval | After reshape | preds~{predictions.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        print_flush(f"Eval | After reshape | refs~{references.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        
    nan_mask = torch.isnan(predictions) | torch.isnan(references)
    predictions = torch.where(nan_mask, torch.tensor(0.0), predictions)
    references = torch.where(nan_mask, torch.tensor(0.0), references)
    if verbose > 0: 
        print_flush(f"Eval | After NaN | preds~{predictions.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        print_flush(f"Eval | After NaN | refs~{references.shape}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    return predictions, references

# %% ../nbs/encoder.ipynb 46
def fine_tune_moment_eval_step_(
    enc_learn : Learner,
    batch,
    mse_metric, 
    rmse_metric,
    mae_metric,
    smape_metric,
    cpu       : bool = False,
    verbose   : int = 0,
    # Print options
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a'
):
    with torch.no_grad():
        output, enc_learn = sure_eval_moment(
            enc_learn = enc_learn, 
            cpu = cpu,
            verbose = verbose,                     
            y = batch, 
            input_mask = None,
            mask = None,
            padd_step = 100, 
            max_trials = 5, 
            acts_indices = None,
            print_to_path = print_to_path, print_path = print_path, print_mode = print_mode
        )
        predictions = output.reconstruction
        references = batch
        predictions = predictions.to(device)
        references = references.to(device)
        predictions, references = fine_tune_moment_eval_preprocess(predictions = predictions, references = references, verbose = verbose, print_to_path = print_to_path, print_path = print_path, print_mode = print_mode)
        mse_metric.add_batch(predictions=predictions, references = references)
        rmse_metric.add_batch(predictions=predictions, references = references)
        mae_metric.add_batch(predictions=predictions, references = references)
        smape_metric.add_batch(predictions=predictions, references = references)
        return mse_metric, rmse_metric, mae_metric, smape_metric

# %% ../nbs/encoder.ipynb 47
def fine_tune_moment_eval_(
    enc_learn : Learner,
    dl_eval   : DataLoader,
    num_epochs: int = 1,
    cpu       : bool = False,
    verbose   : int = 0,
    # Print options
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a'
):
    # Select device
    device = "cpu" if cpu else torch.cuda.current_device()
    # Load metrics
    mse_metric = evaluate.load('mse', "multilist")
    rmse_metric = evaluate.load('mse', "multilist")
    mae_metric = evaluate.load('mae', "multilist")
    smape_metric = evaluate.load("smape", "multilist")
    num_evaluation_steps = len(dl_eval)
    enc_learn = enc_learn.to(device)
    enc_learn.eval()
    #if print_to_path:
    #    pf = open(os.path.expanduser(print_path + "_progress"), "w")
    #    progress_bar = tqdm(range(num_evaluation_steps), file = pf)
    #    # Predict evaluation dataset
    #    for batch in dl_eval:
    #        batch = batch.to(device)
    #        mse_metric, rmse_metric, mae_metric, smape_metric = fine_tune_moment_eval_step_(
    #            enc_learn = enc_learn, 
    #            batch = batch, 
    #            mse_metric = mse_metric, 
    #            rmse_metric = rmse_metric,
    #            mae_metric = mae_metric,
    #            smape_metric = smape_metric,
    #        )
    #        progress_bar.update(1)
    #    progress_bar.close()
    #else:
    progress_bar = tqdm(range(num_evaluation_steps))
    for batch in dl_eval:
        batch = batch.to(device)
        mse_metric, rmse_metric, mae_metric, smape_metric = fine_tune_moment_eval_step_(
            enc_learn = enc_learn, 
            batch = batch, 
            mse_metric = mse_metric, 
            rmse_metric = rmse_metric,
            mae_metric = mae_metric,
            smape_metric = smape_metric,
        )
        progress_bar.update(1)
    progress_bar.close()
    mse   = mse_metric.compute(squared = False)
    rmse  = rmse_metric.compute(squared = True)
    mae   = mae_metric.compute()
    smape = smape_metric.compute()
    eval_results = {
        "mse": mse,
        "rmse": rmse,
        "mae": mae,
        "smape": smape
    }
    enc_learn.train()
    return eval_results

# %% ../nbs/encoder.ipynb 48
def fine_tune_moment_train_loop_step_(
    enc_learn,
    batch, 
    batch_masks,
    criterion                               = torch.nn.MSELoss, 
    window_mask_percent             : float = 0.3,
    optimizer                               = torch.optim.AdamW, 
    lr                              : float = 1e-4, 
    lr_scheduler_flag               : bool  = False, 
    lr_scheduler_name               : str   = "linear",
    lr_scheduler_num_warmup_steps   : int   = None,
    cpu                             : bool  = False,
    verbose                         : int   = 0,
    print_to_path                   : bool  = False,
    print_path                      : str   = "~/data/logs/logs.txt",
    print_mode                      : str   = 'a',
    use_moment_masks                : bool  = False,
    mask_stateful                   : bool  = False,
    mask_future                     : bool  = False,
    mask_sync                       : bool  = False
): 
    device = torch.cuda.current_device() if not cpu else "cpu"
    bms = batch_masks
    if use_moment_masks:
        mask_generator = Masking(mask_ratio = window_mask_percent)
    
    if batch.shape[0] < batch_masks.shape[0]:  
        bms = batch_masks[:batch.shape[0]]
    if verbose > 1: 
        print_flush(
            f"fine_tune_moment_train_loop_step_ | Fine tune loop | batch ~ {batch.shape} | batch_masks ~ {bms.shape}",
            print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose
        )
    
    batch   = batch.to(device)
    bms     = bms.to(device) 

    if bms.shape[0] > batch.shape[0]: bms = bms[:batch.shape[0]]
    if verbose > 0: 
        print_flush(
            f"fine_tune_moment_train_loop_step_ | Fine tune loop | window_mask_percent {window_mask_percent} | batch ~ {batch.shape}",
            print_to_path=print_to_path, print_path=print_path,
            print_mode = 'a', verbose = verbose
        )
    if use_moment_masks:
        mask = mask_generator.generate_mask(
            x = batch,
            input_mask = bms
        )
    else: 
        o   = torch.zeros(batch.shape[0], batch.shape[2])
        if verbose > 0: 
            print_flush(
                f"fine_tune_moment_train_loop_step_ | Fine tune loop | o ~ {o.shape} | stateful = {mask_stateful} | sync = {mask_sync} | r = {window_mask_percent}",
                print_to_path=print_to_path, print_path=print_path,
                print_mode = 'a', verbose = verbose
            )
        if mask_future:
            mask = create_future_mask(
                o       = o, 
                r       = window_mask_percent, 
                sync    = mask_sync
            )[0,:,:].int() # As there is only 1 variable/variables are flattened, an extra dim is created by the masking function
        else:
            mask = create_subsequence_mask(
                o       = o,
                r       = window_mask_percent,
                stateful= mask_stateful,
                sync    = mask_sync
            )[0,:,:].int() # As there is only 1 variable/variables are flattened, an extra dim is created by the masking function
        if verbose > 0:
            print_flush(
                f"fine_tune_moment_train_loop_step_ | Fine tune loop | Before shape adjustment | batch ~ {batch.shape} | batch_masks ~ {bms.shape} | mask ~ {mask.shape}",
                print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose
            )

    if mask.shape[0] < bms.shape[0]:  bms = batch_masks[:mask.shape[0]]
    if mask.shape[1]  < batch_masks.shape[1] :
        mask = torch.nn.functional.pad(mask,(0,batch_masks.shape[1]-mask.shape[1]))
    
    batch = batch.to(device)
    mask = mask.to(device)
    bms = bms.to(device)
    #print_flush(f"fine_tune_moment_train_loop_step_ | Enc_learn Before sure_eval_moment {enc_learn.__class__}")
    enc_learn = enc_learn.to(device)
    if verbose > 1: 
        print_flush(
            f"fine_tune_moment_train_loop_step_ | Fine tune loop | batch ~ {batch.shape} | batch_masks ~ {bms.shape} | mask ~ {mask.shape}",
            print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose
        )
    for param in enc_learn.parameters():
        param = param.to(device)
    if verbose > 1: 
        print_flush(
            f"fine_tune_moment_train_loop_step_ | sure_eval_moment | b{batch.device} | m{mask.device} | bm{bms.device}",
            print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose
        )
    output, enc_learn = sure_eval_moment(
        enc_learn = enc_learn, 
        cpu = cpu,
        verbose = verbose, 
        y = batch, 
        input_mask = bms, # None
        mask = mask, # None
        padd_step = 100, 
        max_trials = 5, 
        acts_indices = None,
        print_to_path = print_to_path, print_path = print_path, print_mode = 'a',
        continue_if_fail = True
    )
    #print_flush(f"fine_tune_moment_train_loop_step_ | Enc_learn After sure_eval_moment {enc_learn.__class__}")
    # Compute output loss
    if output is None:
        print_flush(
            f"fine_tune_moment_train_loop_step_ | Execution failed | Output none ",
            print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose
        )
        loss = 0
    else: 
        loss = fine_tune_moment_compute_loss(batch, output, criterion, verbose = verbose, input_mask = bms, mask = mask, print_to_path = print_to_path, print_path = print_path, print_mode = 'a')
        #print_flush(f"fine_tune_moment_train_loop_step_ | Enc_learn After compute loss {enc_learn.__class__} | -->")
    return loss, enc_learn

# %% ../nbs/encoder.ipynb 49
def fine_tune_moment_train_(
    enc_learn                       : Learner, 
    dl_train                        : DataLoader,
    ds_train                        : pd.DataFrame,
    window_mask_percent             : float = 0.3,
    batch_size                      : int   = 1,
    num_epochs                      : int   = 1,
    criterion                               = torch.nn.MSELoss, 
    optimizer                               = None, 
    lr                              : float = 5e-5,  #1 e -4
    lr_scheduler_flag               : bool  = False, 
    lr_scheduler_name               : str   = "linear",
    lr_scheduler_num_warmup_steps   : int   = None,
    cpu                             : bool  = False,
    verbose                         : int   = 0,
    print_to_path                   : bool  = False,
    print_path                      : str   = "~/data/logs/logs.txt",
    print_mode                      : str   = 'a',
    use_moment_masks                : bool  = False,
    mask_stateful                   : bool  = False,
    mask_future                     : bool  = False,
    mask_sync                       : bool  = False
):
    # Select device
    device = "cpu" if cpu else torch.cuda.current_device()
    # Optimizer and learning rate scheduler
    if optimizer is None: 
        optimizer = torch.optim.AdamW(enc_learn.parameters(), lr)
    num_training_steps = num_epochs * len(dl_train)
    losses = []
    if lr_scheduler_flag:
        lr_scheduler = setup_scheduler(
            dl_train=dl_train, lr_scheduler_flag=lr_scheduler_flag, lr_scheduler_name=lr_scheduler_name,
            optimizer=optimizer, num_epochs = num_epochs, lr_scheduler_num_warmup_steps = lr_scheduler_num_warmup_steps, 
            num_training_steps= num_training_steps, lr = lr
        )
    else:
        lr_scheduler = None
        
    # Training loop
    if verbose > 1: print_flush("fine_tune_moment_train_ | Training loop", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    # Masks
    n_samples, n_channels, window_size = ds_train.shape
    batch_masks = torch.ones(
        (batch_size, window_size), 
        device = device
    ).long()
    if verbose > 1: print_flush(f"fine_tune_moment_train | Fine tune loop | print_to_path {print_to_path} | batch_masks~{batch_masks}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)     
    progress_bar = tqdm(range(num_training_steps))
    if verbose > 0: print_flush(f"fine_tune_moment_train | num_epochs {num_epochs} | n_batches {len(dl_train)}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    for epoch in range(num_epochs):
        for i, batch in enumerate(dl_train):
            if verbose > 0: 
                #print_flush(f"fine_tune_moment_train | batch {i} ~ {batch.shape} | epoch {epoch} | train {i+epoch} of {num_training_steps} | Before loop step | Enc_learn {enc_learn.__class__}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path, print_both = False)
                print_flush(f"fine_tune_moment_train | batch {i} ~ {batch.shape} | epoch {epoch} | train {i+epoch} of {num_training_steps} | Before loop step", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path, print_both = False)
            loss, enc_learn = fine_tune_moment_train_loop_step_(
                    enc_learn                       = enc_learn,
                    batch                           = batch,
                    batch_masks                     = batch_masks, 
                    window_mask_percent             = window_mask_percent,
                    criterion                       = criterion,
                    optimizer                       = optimizer,
                    lr                              = lr,
                    lr_scheduler_flag               = lr_scheduler_flag,
                    lr_scheduler_num_warmup_steps   = lr_scheduler_num_warmup_steps,
                    cpu                             = cpu,
                    verbose                         = verbose,
                    print_to_path                   = print_to_path,
                    print_mode                      = 'a',
                    use_moment_masks                = use_moment_masks,
                    mask_stateful                   = mask_stateful,
                    mask_future                     = mask_future,
                    mask_sync                       = mask_sync
                )
            try: 
                if verbose > 0: print_flush(
                    #f"fine_tune_moment_train | batch {i} ~ {batch.shape} | epoch {epoch} | train {i+epoch} of {num_training_steps} | Loss backward | After loop step | Enc_learn {enc_learn.__class__}", 
                    f"fine_tune_moment_train | batch {i} ~ {batch.shape} | epoch {epoch} | train {i+epoch} of {num_training_steps} | Loss backward | After loop step ", 
                    print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path, print_both = False
                )
                if isinstance(loss, int):
                    losses.append(loss)    
                else:
                    losses.append(loss.item())
                    loss.backward()
                optimizer.zero_grad()  
                optimizer.step()
            except Exception as e: 
                print_flush(f"fine_tune_moment_train | batch {i} ~ {batch.shape} | epoch {epoch} | train {i+epoch} of {num_training_steps} | Loss backward failed: {e}", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
                if isinstance(loss, int):
                    losses.append(loss)                    
                else:
                    losses.append(np.nan)
                optimizer.zero_grad()
                optimizer.step()
            #if verbose > 0: 
                #print_flush(
                #    f"fine_tune_moment_train | batch {i} | After losses | Enc_learn {enc_learn.__class__}", 
                #    print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path, print_both = False
                #)
                
            
            if lr_scheduler_flag: lr_scheduler.step()
            progress_bar.update(1)
    progress_bar.close()
    if verbose > 0:
        #print_flush(f"fine_tune_moment_train | enc_learn {enc_learn.__class__} | -->", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
        print_flush(f"fine_tune_moment_train | -->", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    return losses, enc_learn

# %% ../nbs/encoder.ipynb 50
def fine_tune_moment_single_(
    X                               : List [ List [ List [ float ]]],
    enc_learn                       : Learner, 
    stride                          : int           = 1,      
    batch_size                      : int           = 32,
    cpu                             : bool          = False,
    to_numpy                        : bool          = True, 
    verbose                         : int           = 0, 
    time_flag                       : bool          = False,
    n_windows                       : int           = None,
    n_windows_percent               : float         = None,
    validation_percent              : float         = 0.2, 
    training_percent                : float         = 0.2,
    window_mask_percent             : float         = 0.3,
    num_epochs                      : int           = 3,
    shot                            : bool          = True,
    eval_pre                        : bool          = True,
    eval_post                       : bool          = True,
    criterion                       : _Loss         = torch.nn.MSELoss, 
    optimizer                                       = torch.optim.Adam, 
    lr                              : float         =  5e-5, # 1e-4
    lr_scheduler_flag               : bool          = False, 
    lr_scheduler_name               : str           = "linear",
    lr_scheduler_num_warmup_steps   : int           = 0,
    print_to_path                   : bool          = False,
    print_path                      : str           = "~/data/logs/logs.txt",
    print_mode                      : str           = 'a',
    use_moment_masks                : bool          = False,
    mask_stateful                   : bool          = False,
    mask_future                     : bool          = False,
    mask_sync                       : bool          = False
):
    if verbose > 0: print_flush("--> fine_tune_moment_single", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose )
    t_shot = 0
    t_eval_1 = 0
    t_eval_2 = 0
    losses = []
    eval_results_pre = ""
    eval_results_post = ""

    if time_flag:
        timer = Time()
    if verbose > 0: print_flush("fine_tune_moment_single | Prepare the dataset", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose )
    # Prepare the dataset
    dl_eval, dl_train, ds_train = prepare_train_and_eval_dataloaders(
        X = X, batch_size=batch_size, n_windows = n_windows, n_windows_percent=n_windows_percent,
        training_percent=training_percent, validation_percent=validation_percent, 
        shot = shot, eval_pre = eval_pre, eval_post=eval_post,
        print_to_path=print_to_path, print_path=print_path, print_mode='a', verbose=verbose
    )
    if eval_pre:
        print_flush(f"fine_tune_moment_single | Eval Pre | wlen {X.shape[2]}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        if time_flag: timer.start()
        eval_results_pre = fine_tune_moment_eval_(
            enc_learn = enc_learn,
            dl_eval = dl_eval,
            num_epochs = num_epochs,
            cpu = cpu,
            verbose = verbose-1,
            print_to_path = print_to_path, print_path = print_path, print_mode = 'a'
        )
        if time_flag: 
            timer.end()
            t_eval_1 = timer.duration()
            if verbose > 0: timer.show(verbose = verbose, print_to_path = print_to_path, print_mode = 'a')
    if shot:
        print_flush(f"fine_tune_moment_single | Train | wlen {X.shape[2]}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        try:
            if time_flag: timer.start()
            losses, enc_learn = fine_tune_moment_train_(
                enc_learn = enc_learn,
                dl_train = dl_train,
                ds_train = ds_train,
                window_mask_percent = window_mask_percent,
                batch_size = batch_size,
                num_epochs = num_epochs,
                criterion = criterion, 
                optimizer = optimizer, 
                lr = lr, 
                lr_scheduler_flag = lr_scheduler_flag, 
                lr_scheduler_name = lr_scheduler_name,
                lr_scheduler_num_warmup_steps = lr_scheduler_num_warmup_steps,
                cpu = cpu,
                verbose = verbose-1,
                print_to_path = print_to_path, print_path = print_path, print_mode = 'a',
                use_moment_masks= use_moment_masks,
                mask_stateful=mask_stateful,
                mask_future=mask_future,
                mask_sync=mask_sync
            )
            if time_flag:
                timer.end()
                t_shot = timer.duration()
                if verbose > 0: timer.show(verbose = verbose, print_to_path = print_to_path, print_mode = 'a')
        except Exception as e:
            print_flush(f"fine_tune_moment_single | Train | Window {X.shape[2]} not valid | {e}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
            traceback.print_exc()
    if eval_post:    
        print_flush(f"fine_tune_moment_single | Eval Post | wlen {X.shape[2]}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        if time_flag: timer.start()
        eval_results_post = fine_tune_moment_eval_(
            enc_learn = enc_learn,
            dl_eval = dl_eval,
            num_epochs = num_epochs,
            cpu = cpu,
            verbose = verbose-1,
            print_to_path = print_to_path, print_path = print_path, print_mode = 'a'
        )
        if time_flag:
            timer.end()
            t_eval_2 = timer.duration()
            if verbose > 0: timer.show(verbose = verbose, print_to_path = print_to_path, print_mode = 'a')
            if verbose > 0: 
                print_flush(f"fine_tune_moment_single | Evaluation summary", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                if eval_pre: 
                    print_flush(f"Eval pre: ", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                    show_attrdict(eval_results_pre, print_to_path = print_to_path, print_path = print_path, print_mode = 'a')
                if eval_post: 
                    print_flush(f"Eval post: ", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
                    show_attrdict(eval_results_post, print_to_path = print_to_path, print_path = print_path, print_mode = 'a')
    if verbose > 0: print_flush("fine_tune_moment_single -->", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
    return losses, eval_results_pre, eval_results_post, t_shot, t_eval_1, t_eval_2, enc_learn

# %% ../nbs/encoder.ipynb 51
def fine_tune_moment_(
    dss                             : List [ List [ List [ float ]]],
    enc_learn                       : Learner, 
    enc_args,
    #- Printing options for debugging
    print_args
):   
    print(print_args)
    verbose = print_args['verbose']
    if verbose > 0: print_flush("--> fine_tune_moment_", **print_args)
    print_args['print_mode']='a'
    # Return values
    lossess = []
    eval_results_pre = ""
    eval_results_post = []
    t_shots = []
    t_shot = 0
    t_evals = []
    t_eval = 0
    if verbose > 0: 
        print_flush(
            f"fine_tune_moment_ | Processing {len(dss)} datasets | First length : {dss[0].shape}", 
            **print_args
        )
    # Build optimizer
    if enc_args['optimizer'] is None: 
        if verbose > 0: print_flush(f"fine_tune_moment_ | Setting up optimizer as AdamW", **print_Args)
        enc_args['optimizer'] = torch.optim.AdamW(enc_learn.parameters(), lr=lr)
    # Compute model for each window in the windowed dataset
    for enc_input in dss:
        if verbose > 0: print_flush(f"fine_tune_moment_ | Processing wlen {enc_input.shape[2]}", **print_args)
        ( 
            losses, eval_results_pre_, eval_results_post_, t_shot_, t_eval_1, t_eval_2, enc_learn
        ) =  fine_tune_moment_single_(
            X                               = enc_input, 
            enc_learn                       = enc_learn,
           **enc_args,
           **print_args
        )
        lossess.append(losses)
        if (enc_args['eval_pre']): eval_results_pre = eval_results_pre_
        eval_results_post.append(eval_results_post_)
        t_shots.append(t_shot_)
        if enc_args['eval_pre']: t_evals.append(t_eval_1)
        if enc_args['eval_post']: t_evals.append(t_eval_2)
        enc_args['eval_pre'] = False
    t_shot = sum(t_shots)
    t_eval = sum(t_evals)
    return lossess, eval_results_pre, eval_results_post, t_shots, t_shot, t_evals, t_eval, enc_learn

# %% ../nbs/encoder.ipynb 53
def fine_tune_moment_compute_loss(
    batch, 
    output, 
    criterion   = torch.nn.MSELoss, 
    verbose     = 0, 
    input_mask  = None, 
    mask        = None,
    # Print options
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a'
):
    loss = None
    if verbose > 0: print_flush("--> fine_tune_mvp_compute_loss", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    print_flush("fine_tune_mvp_compute_loss | Not yet implemented", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    if verbose > 0: print_flush("fine_tune_mvp_compute_loss -->", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    return loss

# %% ../nbs/encoder.ipynb 54
def fine_tune_mvp_step_(
    enc_learn : Learner,
    batch,
    mse_metric, 
    rmse_metric,
    mae_metric,
    smape_metric,
    cpu       : bool = False,
    verbose   : int = 0,
    # Print options
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a'
):
    if verbose > 0: print_flush("--> fine_tune_mvp_compute_loss", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    print_flush("fine_tune_mvp_step_ | Not yet implemented", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    if verbose > 0: print_flush("fine_tune_mvp_compute_loss -->", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)


# %% ../nbs/encoder.ipynb 55
def fine_tune_mvp_train_loop_step_(
    # Print options
    print_to_path   : bool          = False,
    print_path      : str           = "~/data/logs/logs.txt",
    print_mode      : str           = 'a'
):
    if verbose > 0: print_flush("--> fine_tune_mvp_train_loop_step_", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    print_flush("fine_tune_mvp_train_loop_step_ | Not yet implemented", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    if verbose > 0: print_flush("fine_tune_mvp_train_loop_step_ -->", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)

# %% ../nbs/encoder.ipynb 56
def fine_tune_mvp_train_(
    verbose                         : int   = 0,
    print_to_path                   : bool  = False,
    print_path                      : str   = "~/data/logs/logs.txt",
    print_mode                      : str   = 'a'
):
    if verbose > 0: print_flush("--> fine_tune_mvp_train_", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    print_flush("fine_tune_mvp_train_ | Not yet implemented", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    if verbose > 0: print_flush("fine_tune_mvp_train_ -->", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)

# %% ../nbs/encoder.ipynb 57
def fine_tune_mvp_single_(
    X                               : List [ List [ List [ float ] ] ],
    validation_percent              : float         = 0.2, 
    training_percent                : float         = 0.2,
    window_mask_percent             : float         = 0.3,
    mask_stateful                   : bool          = False,
    mask_future                     : bool          = False,
    mask_sync                       : bool          = False,
    time_flag                       : bool          = False,
    # -- Print options
    show_plot                       : bool  = False,
    verbose                         : int   = 0,
    print_to_path                   : bool  = False,
    print_path                      : str   = "~/data/logs/logs.txt",
    print_mode                      : str   = 'a',
    use_wandb                       : bool  = True
):
    if verbose > 0: print_flush("--> fine_tune_mvp_single_", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    t_shot = t_eval_1 = t_eval_2 = 0
    losses = []
    eval_results_pre = eval_results_post = ""
    if time_flag: 
        timer = Time()
    n_windows_percent = validation_percent + training_percent 
    X = random_windows(
        X = X, percent     = window_percent, verbose     = verbose-1,#- Printing options for debugging
        print_to_path = print_to_path,
        print_path = print_path,
        print_mode  = 'a'
    )
    splits = TimeSplitter(valid_size = validation_percent, show_plot = show_plot)(X)
    cbs = L(WandbCallback(log_preds=False)) if use_wandb else L()
    tfms = [ToFloat(), None]
    batch_tfms = [TSStandardize(by_sample=config.norm_by_sample, 
               use_single_batch=config.norm_use_single_batch)]
    learn = ts_learner(
    dls, InceptionTimePlus, cbs= cbs + sgc + MVP(
            r = config.r, 
            window_size=config.mvp_ws, 
            future_mask = config.mask_future, 
            target_dir='./models', 
            sync = config.mask_sync, 
            stateful = config.mask_stateful,
            fname=f'encoder_MVP'
        ), y_range=[X.min(), X.max()])
    dls = get_ts_dls(X, splits=splits, tfms=tfms, bs=config.batch_size, batch_tfms=batch_tfms)
    
    if verbose > 0: print_flush("Fine tune MVP single | Split training dataset into training and test datasets",print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    
    if verbose > 0: print_flush("fine_tune_mvp_single_ -->", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)

# %% ../nbs/encoder.ipynb 58
def fine_tune_mvp_(
    dss                             : List [ List [ List [ float ]]],
    enc_learn                       : Learner, 
    stride                          : int           = 1,      
    batch_size                      : int           = 32,
    cpu                             : bool          = False,
    to_numpy                        : bool          = True, 
    verbose                         : int           = 0, 
    time_flag                       : bool          = False,
    n_windows                       : int           = None,
    n_windows_percent               : float         = None,
    validation_percent              : float         = 0.2, 
    training_percent                : float         = 0.2,
    window_mask_percent             : float         = 0.3,
    num_epochs                      : int           = 3,
    shot                            : bool          = True,
    eval_pre                        : bool          = True,
    eval_post                       : bool          = True,
    criterion                       : _Loss         = torch.nn.MSELoss, 
    optimizer                                       = None, 
    lr                              : float         = 5e-5, #1e-4, 
    lr_scheduler_flag               : bool          = False, 
    lr_scheduler_name               : str           = "linear",
    lr_scheduler_num_warmup_steps   : int           = None,
    #- Printing options for debugging
    print_to_path                   : bool          = False,
    print_path                      : str           = "~/data/logs/logs.txt",
    print_mode                      : str           = 'a',
    use_moment_masks                : bool          = False,
    mask_stateful                   : bool          = False,
    mask_future                     : bool          = False,
    mask_sync                       : bool          = False
):   
    if verbose > 0: print_flush("--> fine_tune_moment_", print_to_path = print_to_path, print_path = print_path, print_mode = print_mode, verbose = verbose, print_time = print_to_path)
    lossess = []
    eval_results_pre = ""
    eval_results_post = []
    t_shots = []
    t_shot = 0
    t_evals = []
    t_eval = 0
    if verbose > 0: 
        print_flush(
            f"fine_tune_moment_ | Processing {len(dss)} datasets | First length : {dss[0].shape}", 
            print_to_path = print_to_path, 
            print_path = print_path, 
            print_mode = 'a', 
            verbose = verbose, 
            print_time = print_to_path
        )
    
    if optimizer is None: 
        if verbose > 0: print_flush(f"fine_tune_moment_ | Setting up optimizer as AdamW", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        optimizer = torch.optim.AdamW(enc_learn.parameters(), lr=lr)
    
    for enc_input in dss:
        if verbose > 0: print_flush(f"fine_tune_moment_ | Processing wlen {enc_input.shape[2]}", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = verbose, print_time = print_to_path)
        ( 
            losses, eval_results_pre_, eval_results_post_, t_shot_, t_eval_1, t_eval_2, enc_learn
        ) =  fine_tune_mvp_single_(
            X                               = enc_input, 
            enc_learn                       = enc_learn,
            stride                          = stride,
            batch_size                      = batch_size,
            cpu                             = cpu,
            to_numpy                        = to_numpy,
            verbose                         = verbose,
            time_flag                       = time_flag,
            n_windows                       = n_windows,
            n_windows_percent               = n_windows_percent,
            validation_percent              = validation_percent,
            training_percent                = training_percent,
            window_mask_percent             = window_mask_percent,
            num_epochs                      = num_epochs,
            shot                            = shot,
            eval_pre                        = eval_pre,
            eval_post                       = eval_post,
            criterion                       = criterion,
            optimizer                       = optimizer,
            lr                              = lr,
            lr_scheduler_flag               = lr_scheduler_flag,
            lr_scheduler_name               = lr_scheduler_name,
            lr_scheduler_num_warmup_steps   = lr_scheduler_num_warmup_steps,
            print_to_path = print_to_path, print_path = print_path, print_mode = 'a',
            use_moment_masks                = use_moment_masks,
            mask_stateful                   = mask_stateful,
            mask_future                     = mask_future,
            mask_sync                       = mask_sync
        )
        
        lossess.append(losses)
        if (eval_pre): eval_results_pre = eval_results_pre_
        eval_results_post.append(eval_results_post_)
        t_shots.append(t_shot_)
        if eval_pre: t_evals.append(t_eval_1)
        if eval_post: t_evals.append(t_eval_2)
        eval_pre = False
    t_shot = sum(t_shots)
    t_eval = sum(t_evals)
    return lossess, eval_results_pre, eval_results_post, t_shots, t_shot, t_evals, t_eval, enc_learn

# %% ../nbs/encoder.ipynb 61
def fine_tune_(
    X                               : Union [ List [ List [ List [ float ]]], List [ float ], pd.DataFrame ],
    enc_learn                       : Learner, 
    stride                          : int           = 1,      
    batch_size                      : int           = 32,
    cpu                             : bool          = False,
    to_numpy                        : bool          = True, 
    verbose                         : int           = 0, 
    time_flag                       : bool          = False,
    n_windows                       : int           = None,
    n_windows_percent               : float         = None,
    validation_percent              : float         = 0.2, 
    training_percent                : float         = 0.2,
    window_mask_percent             : float         = 0.3,
    num_epochs                      : int           = 3,
    shot                            : bool          = True,
    eval_pre                        : bool          = True,
    eval_post                       : bool          = True,
    criterion                       : _Loss         = torch.nn.MSELoss, 
    optimizer                                       = None, 
    lr                              : float         = 5e-5, #1e-4, 
    lr_scheduler_flag               : bool          = False, 
    lr_scheduler_name               : str           = "linear",
    lr_scheduler_num_warmup_steps   : int           = None,
    window_sizes                    : List [int]    = None,
    n_window_sizes                  : int           = 1,
    window_sizes_offset             : int           = 0.05,
    windows_min_distance            : int           = 1,
    full_dataset                    : bool          = False,
    #- Printing options for debugging
    print_to_path                   : bool          = False,
    print_path                      : str           = "~/data/logs/logs.txt",
    print_mode                      : str           = 'a',
    use_moment_masks                : bool          = False,
    #- Masking options
    mask_stateful                   : bool          = False,
    mask_future                     : bool          = False,
    mask_sync                       : bool          = False
):      
    mssg = Mssg(mssg = "--> Fine tune ", to_path = print_to_path,path = print_path,mode = print_mode, verbose = verbose)
    print(mssg.mssg)
    mssg.print()
    mssg.styled(color = 'purple')
    lossess, eval_results_pre, eval_results_post, t_shots, t_shot, t_evals, t_eval = ( None, None, None, None, None, None, None )
    enc_learn_class = str(enc_learn.__class__)[8:-2]
    enc_input = windowed_dataset(X, stride, window_sizes, n_window_sizes, window_sizes_offset, windows_min_distance, full_dataset, mssg)
    func = None
    enc_args = {
        "stride": stride,
        "batch_size": batch_size,
        "cpu": cpu,
        "to_numpy": to_numpy,
        "verbose": verbose,
        "time_flag": time_flag,
        "n_windows": n_windows,
        "n_windows_percent": n_windows_percent,
        "validation_percent": validation_percent,
        "training_percent": training_percent,
        "window_mask_percent": window_mask_percent,
        "num_epochs": num_epochs,
        "shot": shot,
        "eval_pre": eval_pre,
        "eval_post": eval_post,
        "criterion": criterion,
        "optimizer": optimizer,
        "lr": lr,
        "lr_scheduler_flag": lr_scheduler_flag,
        "lr_scheduler_name": lr_scheduler_name,
        "lr_scheduler_num_warmup_steps": lr_scheduler_num_warmup_steps,
        "mask_stateful": mask_stateful,
        "mask_future": mask_future,
        "mask_sync": mask_sync
    }
    
    print_args = {
        "print_to_path": print_to_path,
        "print_path": print_path,
        "print_mode": print_mode,
        "verbose": verbose
    }
    match enc_learn_class:
        case "momentfm.models.moment.MOMENTPipeline":
            func = fine_tune_moment_
            enc_args["use_moment_masks"]=use_moment_masks
        case "fastai.learner.Learner":
            func = fine_tune_mvp_
            print_flush("fine_tune | Learner fine_tune not yet implemented", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = 1, print_time = print_to_path)
        case "uni2ts.model.moirai.module.MoiraiModule":
            #func_ = fine_tune_moirai_
            print_flush("fine_tune | Moirai fine_tune not yet implemented", print_to_path = print_to_path, print_path = print_path, print_mode = 'a', verbose = 1, print_time = print_to_path)
            raise NotImplementedError("fine_tune | Moirai fine_tune not yet implemented")

        case _:
            print_flush(f"Fine-tune implementation is not yet implemented for {enc_learn_class}.", verbose = 1)
    if func is not None:
        ( 
            lossess, eval_results_pre, eval_results_post, 
            t_shots, t_shot, t_evals, t_eval, 
            enc_learn 
        ) = func(dss = enc_input, enc_learn = enc_learn, enc_args = enc_args, print_args = print_args)
    else:
        raise NotImplementedError("fine_tune | Fine-tune function is None.")
    return lossess, eval_results_pre, eval_results_post, t_shots, t_shot, t_evals, t_eval, enc_learn

    
