# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/visualization.ipynb (unless otherwise specified).

__all__ = ['check_compatibility', 'get_UMAP_prjs', 'plot_TS', 'plot_validation_ts_ae']

# Cell
import umap
import cudf
import cuml
import pandas as pd
import numpy as np
from fastcore.all import *
from .all import *

# Cell
def check_compatibility(dr_ar:TSArtifact, enc_ar:TSArtifact):
    "Function to check that the artifact used by the encoder model and the artifact that is \
    going to be passed through the DR are compatible"
    try:
        # Check that both artifacts have the same variables
        chk_vars = dr_ar.metadata['TS']['vars'] == enc_ar.metadata['TS']['vars']
        # Check that both artifacts have the same freq
        chk_freq = dr_ar.metadata['TS']['freq'] == enc_ar.metadata['TS']['freq']
        # Check that the dr artifact is not normalized (not normalized data has not the key normalization)
        chk_norm = dr_ar.metadata['TS'].get('normalization') is None
        # Check that the dr artifact has not missing values
        chk_miss = dr_ar.metadata['TS']['has_missing_values'] == "False"
        # Check all logical vars.
        if chk_vars and chk_freq and chk_norm and chk_miss:
            print("Artifacts are compatible.")
        else:
            raise Exception
    except Exception as e:
        print("Artifacts are not compatible.")
        raise e
    return None


# Cell
import warnings
from numba.core.errors import NumbaPerformanceWarning
@delegates(cuml.UMAP)
def get_UMAP_prjs(input_data, cpu=True, **kwargs):
    "Compute the projections of `input_data` using UMAP, with a configuration contained in `**kwargs`."
    warnings.filterwarnings("ignore", category=NumbaPerformanceWarning) # silence NumbaPerformanceWarning
    reducer = umap.UMAP(**kwargs) if cpu else cuml.UMAP(**kwargs)
    projections = reducer.fit_transform(input_data)
    return projections

# Cell
from fastcore.all import *
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Cell
@delegates(pd.DataFrame.plot)
def plot_TS(df:pd.core.frame.DataFrame, **kwargs):
    df.plot(subplots=True, **kwargs)
    plt.show()

# Cell
def plot_validation_ts_ae(prediction:np.array, original:np.array, title_str = "Validation plot", fig_size = (15,15), anchor = (-0.01, 0.89), window_num = 0, return_fig=True, title_pos = 0.9):
    # Create the figure
    fig = plt.figure(figsize=(fig_size[0],fig_size[1]))
    # Create the subplot axes
    axes = fig.subplots(nrows=original.shape[2], ncols=1)
    # We iterate over the sensor data and plot both the original and the prediction
    for i,ax in zip(range(original.shape[2]),fig.axes):
        ax.plot(original[window_num,:,i], label='Original Data')
        ax.plot(prediction[window_num,:,i], label='Prediction')
    # Handle the legend configuration and position
    lines, labels = fig.axes[-1].get_legend_handles_labels()
    fig.legend(lines, labels,loc='upper left', ncol=2)
    # Write the plot title (and position it closer to the top of the graph)
    fig.suptitle(title_str, y = title_pos)
    # Tight results:
    fig.tight_layout()
    # Returns
    if return_fig:
        return fig
    fig
    return None
